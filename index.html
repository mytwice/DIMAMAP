<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DIMA MAP</title>
    <style>
        /* 기본 스타일 */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f9f9f9;
        }

        #map-wrapper {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: relative;
            background: #f5f5f5;
        }

        #map-container {
            position: absolute;
            transform-origin: 0 0;
            cursor: grab;
            width: 100%;
            height: 100%;
        }

        #map-container:active {
            cursor: grabbing;
        }

        #map-image {
            width: 1200px;
            height: 900px;
            user-select: none;
            object-fit: cover;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            -webkit-user-drag: none;
            -khtml-user-drag: none;
            -moz-user-drag: none;
            -o-user-drag: none;
        }

        /* 상단 컨트롤 패널 */
        .control-panel {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 1200px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            z-index: 9999;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;  /* 항목들을 줄 바꿈이 가능하게 함 */
            gap: 16px;  /* 항목 간의 간격 */
        }

        /* 검색창 */
        .search-container {
            flex: 1;
            max-width: 400px;
        }

        .search-input {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            margin-bottom: 10px;
            font-size: 16px;
            box-sizing: border-box;
        }

        /* 필터링 그룹을 1줄에 배치 */
        .filter-group {
            display: flex;
            gap: 16px;
            flex-wrap: nowrap;  /* 필터 그룹은 한 줄에 배치 */
        }

        /* 카테고리 필터는 2줄로 배치 */
        #category-filter {
            display: flex;
            flex-wrap: wrap;  /* 라벨들을 2줄로 배치 */
            gap: 16px;
            width: 100%;  /* 전체 너비 사용 */
        }

        #category-filter label {
            box-sizing: border-box;
        }

        .filter-group label {
            display: block;
            margin-bottom: 5px;
            color: #666;
            font-size: 14px;
        }

        .filter-select {
            width: 150px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        .filter-button {
            padding: 12px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s;
        }

        .filter-button:hover {
            background: #1976D2;
        }

        /* 네비게이션 버튼 */
        .nav-buttons {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .nav-button {
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
        }

        .nav-button:hover {
            background-color: #45a049;
        }

        /* 핀 및 정보 박스 */
        .pin {
            position: absolute;
            width: 30px;
            height: 30px;
            transform: translate(-50%, -100%);
            z-index: 1000;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .pin:hover {
            transform: translate(-50%, -100%) scale(1.1);
        }

        .pin::before {
            content: '';
            position: absolute;
            width: 30px;
            height: 30px;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23E91E63"><path d="M12 0C7.6 0 4 3.6 4 8c0 5.4 8 16 8 16s8-10.6 8-16c0-4.4-3.6-8-8-8zm0 12c-2.2 0-4-1.8-4-4s1.8-4 4-4 4 1.8 4 4-1.8 4-4 4z"/></svg>') no-repeat center center;
            background-size: contain;
        }

        .pin-info-box {
            position: fixed;
            background: white;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: none;
            z-index: 1001;
            max-width: 300px;
            font-size: 14px;
            line-height: 1.6;
        }

        .pin-info-box strong {
            color: #333;
            display: inline-block;
            width: 80px;
        }

        .pin-info-box a {
            color: #2196F3;
            text-decoration: none;
        }

        .pin-info-box a:hover {
            text-decoration: underline;
        }

        .pin-info-box .close-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 18px;
            cursor: pointer;
            color: #666;
            line-height: 1;
        }

        .pin-info-box .close-btn:hover {
            color: #333;
        }

    /* 모바일에서 토글 버튼 */
    .toggle-button {
        display: none;
    }

    /* 모바일에서 control-panel 숨기기 */
    @media (max-width: 768px) {
        .control-panel {
            display: none; /* 모바일에서는 숨깁니다 */
            flex-direction: column;
            align-items: stretch;
            width: 70%;
            left: -00%;
            top: 90px;
        }
        .search-input {
            width: 50%;
        }
        .toggle-button {
            display: block;
            position: fixed;
            top: 16px;
            left: 16px;
            background-color: #333;
            color: #fff;
            padding: 10px;
            font-size: 24px;
            border: none;
            cursor: pointer;
            z-index: 1000; /* 버튼이 항상 위에 표시되도록 */
        }

        /* control-panel을 보이게 할 때 */
        .control-panel.show {
            display: flex; /* 토글 시 보이게 설정 */
            transition: transform 0.3s ease-in-out;
            transform: translateY(0); /* 부드럽게 위로 나타나도록 설정 */
        }

        /* 추가된 필터, 카테고리 등의 스타일 조정 */
        .filter-group {
            flex-direction: column;
            gap: 12px;
        }

        #category-filter {
            flex-direction: column;
        }

        #category-filter label {
            width: 100%;
        }
    }

    @media (max-width: 480px) {
        /* 작은 화면에서 라벨 크기 및 입력 크기 조정 */
        .search-input {
            font-size: 14px;
            padding: 6px;
        }

        .filter-select {
            font-size: 14px;
            padding: 6px;
        }
    }
    </style>
</head>
<body>
    <div class="control-panel">
        <!-- 검색 창 -->
        <div class="search-container">
            <input type="text" class="search-input" placeholder="검색어를 입력하세요..." id="search-input">
        </div>

        <!-- 필터링 -->
        <div class="filter-group">
            <label for="building-filter">건물</label>
            <select id="building-filter" class="filter-select"></select>

            <label for="floor-filter">층</label>
            <select id="floor-filter" class="filter-select"></select>
        </div>

        <!-- 카테고리 필터 -->
        <div id="category-filter">
            <label><input type="checkbox" name="category" value=""> 전체</label>
            <!-- 동적으로 카테고리 라디오 버튼 추가 -->
        </div>       
    </div>

    <!-- 모바일 토글 버튼 -->
    <button class="toggle-button" id="toggle-button">☰</button>
</body>

    <div id="map-wrapper">
        <div id="map-container">
            <img id="map-image" src="map.png" alt="지도" draggable="false">
        </div>
    </div>

    <!-- 네비게이션 버튼 -->
    <div class="nav-buttons">
        <button class="nav-button">홈</button>
        <button class="nav-button">길찾기</button>
        <button class="nav-button">즐겨찾기</button>
        <button class="nav-button">공지사항</button>
        <button class="nav-button">설정</button>
    </div>

<script>
// 변수 선언
const mapWrapper = document.getElementById('map-wrapper');
const mapContainer = document.getElementById('map-container');
const searchInput = document.getElementById('search-input');
const searchResults = document.getElementById('search-results');
let pins = [];
let isDragging = false;
let startX, startY;
let currentTranslateX = 0, currentTranslateY = 0, currentScale = 1;
let mode = 'move';
let selectedPin = null;
let activeInfoBox = null;
let lastTouchDistance = 0;
let zoomAnimation;
let initialTouchX, initialTouchY;
let isTouchMoving = false;
let lastTouchTime = 0;
const TOUCH_DELAY = 300; // 더블탭 감지를 위한 시간 간격 (ms)

// 맵 설정
const mapConfig = {
    initialScale: 1.8,
    initialX: -0,
    initialY: -80,
    minScale: 1.6,
    maxScale: 9,
    zoomSpeed: 1,
    mobile: {
        initialScale: 0.94,
        initialX: -210,
        initialY: -10
    }
};

// 핀 데이터
const pinsData = [
  {
    "x": "588.89",
    "y": "530.89",
    "building": "체육관",
    "floor": "1",
    "category": "운동",
    "name": "체육관",
    "description": "",
    "address": ""
  },
  {
    "x": "568.89",
    "y": "483.89",
    "building": "대학본부",
    "floor": "1",
    "category": "도서관",
    "name": "도서관",
    "description": "",
    "address": "https://lib.dima.ac.kr/"
  },
  {
    "x": "526.89",
    "y": "368.89",
    "building": "덕성관",
    "floor": "4",
    "category": "실습실",
    "name": "C3 스튜디오",
    "description": "이곳에 들어가면 못나온다~",
    "address": ""
  },
  {
    "x": "573.89",
    "y": "393.89",
    "building": "기예관",
    "floor": "1",
    "category": "실습실",
    "name": "스튜디오",
    "description": "HD부터 다양한 스튜디오가 있음",
    "address": ""
  },
  {
    "x": "254.89",
    "y": "136.89",
    "building": "예인관",
    "floor": "B1",
    "category": "편의시설",
    "name": "GS25",
    "description": "야간 무인운영함",
    "address": ""
  },
  {
    "x": "239.89",
    "y": "201.89",
    "building": "엔터테인먼트관",
    "floor": "2",
    "category": "공연장",
    "name": "대공연장",
    "description": "나중에 디마아트와 연계예정",
    "address": ""
  },
  {
    "x": "263.89",
    "y": "335.89",
    "building": "디마종합촬영소",
    "floor": "1",
    "category": "",
    "name": "디마종합촬영소",
    "description": "자세한정보제공 못함",
    "address": ""
  },
  {
    "x": "654.89",
    "y": "559.89",
    "building": "정류장",
    "floor": "야외",
    "category": "정류장",
    "name": "운동장정류장",
    "description": "",
    "address": ""
  },
  {
    "x": "884.89",
    "y": "631.89",
    "building": "정류장",
    "floor": "야외",
    "category": "정류장",
    "name": "원룸촌 셔틀버스",
    "description": "",
    "address": ""
  }
];

// 필터 옵션 초기화 함수 (카테고리 라디오박스로 변경)
function initializeFilterOptions() {
    const buildingFilter = document.getElementById('building-filter');
    const floorFilter = document.getElementById('floor-filter');
    const categoryFilter = document.getElementById('category-filter');

    const buildings = [...new Set(pinsData.map(pin => pin.building))];
    const floors = [...new Set(pinsData.map(pin => pin.floor))];
    const categories = [...new Set(pinsData.map(pin => pin.category))];

    // 필터 옵션 채우기
    function populateFilter(filter, options, type = 'select') {
        if (type === 'checkbox') {
            filter.innerHTML = ''; // 기존 콘텐츠 초기화
            options.forEach(option => {
                if (option) {
                    const label = document.createElement('label');
                    label.innerHTML = `<input type="checkbox" name="category" value="${option}">${option}</label>`;
                    filter.appendChild(label);
                }
            });
        } else {
            filter.innerHTML = '<option value="">전체</option>';
            options.forEach(option => {
                if (option) {
                    filter.innerHTML += `<option value="${option}">${option}</option>`;
                }
            });
        }
    }

    populateFilter(buildingFilter, buildings);
    populateFilter(floorFilter, floors);
    populateFilter(categoryFilter, categories, 'checkbox');
}

// 검색 기능
searchInput.addEventListener('input', function() {
    const searchTerm = this.value.toLowerCase();
    if (searchTerm.length < 1) {
        searchResults.style.display = 'none';
        return;
    }

    const filteredPins = pinsData.filter(pin => 
        pin.name.toLowerCase().includes(searchTerm) ||
        pin.building.toLowerCase().includes(searchTerm) ||
        pin.description.toLowerCase().includes(searchTerm)
    );

    searchResults.innerHTML = '';
    if (filteredPins.length > 0) {
        filteredPins.forEach(pin => {
            const resultItem = document.createElement('div');
            resultItem.className = 'search-result-item';
            resultItem.innerHTML = `
                <div><strong>${pin.name}</strong></div>
                <div>${pin.building} ${pin.floor}</div>
            `;
            resultItem.addEventListener('click', () => {
                const pinObj = pins.find(p => 
                    p.coordinates.x === pin.x && 
                    p.coordinates.y === pin.y
                );
                if (pinObj) {
                    moveToPin(pinObj.pin);
                    showPinInfoBox(pinObj.pin, pin);
                }
                searchResults.style.display = 'none';
                searchInput.value = '';
            });
            searchResults.appendChild(resultItem);
        });
        searchResults.style.display = 'block';
    } else {
        searchResults.style.display = 'none';
    }
});

// updateMapTransform 함수 수정 
function updateMapTransform() {
    const wrapperWidth = mapWrapper.offsetWidth;
    const wrapperHeight = mapWrapper.offsetHeight;
    const mapWidth = 1200 * currentScale;
    const mapHeight = 900 * currentScale;

    // 경계 제한
    const minX = Math.min(0, wrapperWidth - mapWidth);
    const minY = Math.min(0, wrapperHeight - mapHeight);

    currentTranslateX = Math.max(minX, Math.min(0, currentTranslateX));
    currentTranslateY = Math.max(minY, Math.min(0, currentTranslateY));

    // transform 적용
    mapContainer.style.transform = 
        `translate(${currentTranslateX}px, ${currentTranslateY}px) scale(${currentScale})`;

    // 핀 정보창 위치 업데이트
    if (activeInfoBox && selectedPin) {
        const pinRect = selectedPin.getBoundingClientRect();
        activeInfoBox.style.left = `${pinRect.left}px`;
        activeInfoBox.style.top = `${pinRect.top - 100}px`;
    }
}

function animateScroll(targetX, targetY) {
    const duration = 800; // 애니메이션 지속 시간 (ms)
    const startX = currentTranslateX;
    const startY = currentTranslateY;
    const deltaX = targetX - startX;
    const deltaY = targetY - startY;
    const startTime = performance.now();

    function scrollStep(currentTime) {
        const progress = Math.min((currentTime - startTime) / duration, 1);
        const easeProgress = 1 - Math.pow(1 - progress, 2); // easeOutQuad

        currentTranslateX = startX + deltaX * easeProgress;
        currentTranslateY = startY + deltaY * easeProgress;

        updateMapTransform();

        if (progress < 1) {
            requestAnimationFrame(scrollStep);
        }
    }

    requestAnimationFrame(scrollStep);
}

// 핀 생성 함수
function createPin(x, y, details = {}) {
    const pin = document.createElement('div');
    pin.className = 'pin';
    pin.style.left = `${x}px`;
    pin.style.top = `${y}px`;

    pin.addEventListener('click', function(e) {
        e.stopPropagation();
        showPinInfoBox(pin, details);
    });

    mapContainer.appendChild(pin);
    pins.push({
        pin,
        coordinates: { x, y },
        ...details
    });
}

// 핀 정보창 표시 함수
function showPinInfoBox(pin, pinData) {
    if (activeInfoBox) {
        activeInfoBox.remove();
    }

    const pinRect = pin.getBoundingClientRect();
    const infoBox = document.createElement('div');
    infoBox.className = 'pin-info-box';
    
    infoBox.style.left = `${pinRect.left}px`;
    infoBox.style.top = `${pinRect.top - 100}px`;

    const closeBtn = document.createElement('span');
    closeBtn.className = 'close-btn';
    closeBtn.innerHTML = '×';
    closeBtn.onclick = function(e) {
        e.stopPropagation();
        infoBox.style.display = 'none';
        activeInfoBox = null;
    };
    infoBox.appendChild(closeBtn);

    infoBox.innerHTML += `
        <strong>이름:</strong> ${pinData.name || '미정'}<br>
        <strong>건물:</strong> ${pinData.building || '미정'}<br>
        <strong>층:</strong> ${pinData.floor || '미정'}<br>
        <strong>카테고리:</strong> ${pinData.category || '미정'}<br>
        <strong>설명:</strong> ${pinData.description || '미정'}<br>
        <strong>주소:</strong> 
        ${pinData.address ? `<a href="${pinData.address}" target="_blank">${pinData.address}</a>` : '미정'}
    `;
    
    document.body.appendChild(infoBox);
    infoBox.style.display = 'block';
    activeInfoBox = infoBox;
    selectedPin = pin;

    // 정보창이 화면 밖으로 나가지 않도록 조정
    const infoBoxRect = infoBox.getBoundingClientRect();
    if (infoBoxRect.top < 0) {
        infoBox.style.top = '10px';
    }
    if (infoBoxRect.left < 0) {
        infoBox.style.left = '10px';
    }
    if (infoBoxRect.right > window.innerWidth) {
        infoBox.style.left = `${window.innerWidth - infoBoxRect.width - 10}px`;
    }

        // 클릭 이벤트 리스너
        closeBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        infoBox.remove();
        activeInfoBox = null;
        selectedPin = null;
    });

    infoBox.appendChild(closeBtn);
}

// 필터링 함수
function filterPins() {
    const buildingFilter = document.getElementById('building-filter').value;
    const floorFilter = document.getElementById('floor-filter').value;

    // 선택된 카테고리 체크박스 값 가져오기
    const selectedCategories = [...document.querySelectorAll('input[name="category"]:checked')]
        .map(checkbox => checkbox.value);

    pins.forEach(pinObj => {
        const matchesBuilding = !buildingFilter || pinObj.building === buildingFilter;
        const matchesFloor = !floorFilter || pinObj.floor === floorFilter;

        // 선택된 카테고리들 중 하나라도 해당되면 해당 핀을 표시
        const matchesCategory = selectedCategories.length === 0 || selectedCategories.includes(pinObj.category);

        // 모든 조건이 맞으면 핀을 표시, 아니면 숨김
        if (matchesBuilding && matchesFloor && matchesCategory) {
            pinObj.pin.style.display = 'block';
        } else {
            pinObj.pin.style.display = 'none';
        }
    });
}

// 특정 핀으로 이동하는 함수
function moveToPin(pin) {
    const pinRect = pin.getBoundingClientRect();
    const wrapperRect = mapWrapper.getBoundingClientRect();
    
    const targetX = -(pin.offsetLeft * currentScale - (wrapperRect.width / 2));
    const targetY = -(pin.offsetTop * currentScale - (wrapperRect.height / 2));
    
    mapContainer.style.transition = 'transform 0.5s ease-out';
    currentTranslateX = targetX;
    currentTranslateY = targetY;
    updateMapTransform();
    
    setTimeout(() => {
        mapContainer.style.transition = '';
    }, 500);
}

// 부드러운 줌 (줌 속도와 애니메이션 처리 개선)
function smoothZoom(targetScale, mouseX, mouseY) {
    const startScale = currentScale;
    const scaleDiff = targetScale - startScale;
    const duration = 300;

    if (zoomAnimation) {
        cancelAnimationFrame(zoomAnimation);
    }

    // 현재 뷰포트 상의 마우스 위치
    const viewportX = mouseX;
    const viewportY = mouseY;

    // 현재 맵 상의 마우스 위치 계산
    const mapX = (viewportX - currentTranslateX) / currentScale;
    const mapY = (viewportY - currentTranslateY) / currentScale;

    const startTime = performance.now();

    function animate(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // easeOutQuad 이징 함수 사용
        const easeProgress = 1 - (1 - progress) * (1 - progress);
        const newScale = startScale + (scaleDiff * easeProgress);

        // 새로운 translate 값 계산
        // 마우스 위치는 고정된 채로 확대/축소되어야 함
        const newTranslateX = viewportX - (mapX * newScale);
        const newTranslateY = viewportY - (mapY * newScale);

        // 경계 확인
        const mapWidth = 1200 * newScale;
        const mapHeight = 900 * newScale;
        const wrapperWidth = mapWrapper.offsetWidth;
        const wrapperHeight = mapWrapper.offsetHeight;

        // 맵이 화면 밖으로 너무 많이 나가지 않도록 제한
        const minX = Math.min(0, wrapperWidth - mapWidth);
        const minY = Math.min(0, wrapperHeight - mapHeight);

        currentScale = newScale;
        currentTranslateX = Math.max(minX, Math.min(0, newTranslateX));
        currentTranslateY = Math.max(minY, Math.min(0, newTranslateY));

        updateMapTransform();

        if (progress < 1) {
            zoomAnimation = requestAnimationFrame(animate);
        }
    }

    zoomAnimation = requestAnimationFrame(animate);
}

// 터치 확대/축소 감도 조절 및 동작 수정
function getTouchDistance(touches) {
    return Math.hypot(
        touches[0].clientX - touches[1].clientX,
        touches[0].clientY - touches[1].clientY
    );
}

// 터치 시작 이벤트 핸들러
mapContainer.addEventListener('touchstart', function(e) {
    const currentTime = new Date().getTime();
    const touchTimeDiff = currentTime - lastTouchTime;
    
    if (e.touches.length === 2) {
        // 핀치 줌 시작
        e.preventDefault();
        lastTouchDistance = getTouchDistance(e.touches);
        isTouchMoving = false;
    } else if (e.touches.length === 1) {
        // 단일 터치 시작
        initialTouchX = e.touches[0].clientX;
        initialTouchY = e.touches[0].clientY;
        startX = initialTouchX;
        startY = initialTouchY;
        isTouchMoving = false;

        // 더블탭 줌 처리
        if (touchTimeDiff < TOUCH_DELAY) {
            e.preventDefault();
            const rect = mapContainer.getBoundingClientRect();
            const touchX = e.touches[0].clientX - rect.left;
            const touchY = e.touches[0].clientY - rect.top;
            
            // 현재 스케일이 최대값이면 최소값으로, 아니면 최대값으로 줌
            const targetScale = currentScale === mapConfig.maxScale ? 
                mapConfig.minScale : mapConfig.maxScale;
            smoothZoom(targetScale, touchX, touchY);
        }
    }
    
    lastTouchTime = currentTime;
}, { passive: false });

// 마우스 다운 이벤트 핸들러 추가
mapContainer.addEventListener('mousedown', (e) => {
    isDragging = true;
    startX = e.clientX;
    startY = e.clientY;
    mapContainer.style.cursor = 'grabbing';
});

// 마우스 이동 이벤트 핸들러 업데이트
document.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    e.preventDefault();
    const deltaX = e.clientX - startX;
    const deltaY = e.clientY - startY;
    
    currentTranslateX += deltaX;
    currentTranslateY += deltaY;
    
    startX = e.clientX;
    startY = e.clientY;
    
    updateMapTransform();
});

document.addEventListener('mouseup', () => {
    isDragging = false;
    mapContainer.style.cursor = 'grab';
});

// X키 이벤트 리스너
document.addEventListener('keydown', function(e) {
    if (e.key === 'x' || e.key === 'X') {
        if (activeInfoBox) {
            activeInfoBox.style.display = 'none';
            activeInfoBox = null;
        }
        if (searchResults.style.display === 'block') {
            searchResults.style.display = 'none';
            searchInput.value = '';
        }
    }
});

// wheel 이벤트 핸들러 수정
mapWrapper.addEventListener('wheel', function(e) {
    e.preventDefault();
    
    const rect = mapWrapper.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    const delta = -e.deltaY / Math.abs(e.deltaY); // 방향만 추출 (+1 또는 -1)
    const zoomFactor = 0.6; // 줌 속도 조절 (값이 작을수록 부드러움)
    const targetScale = Math.min(
        Math.max(
            mapConfig.minScale,
            currentScale * (1 + delta * zoomFactor)
        ),
        mapConfig.maxScale
    );
    
    // 현재 스케일과 목표 스케일이 충분히 다른 경우에만 줌 실행
    if (Math.abs(targetScale - currentScale) > 0.01) {
        smoothZoom(targetScale, mouseX, mouseY);
    }
});

// 터치 이벤트
mapContainer.addEventListener('touchstart', function(e) {
    if (e.touches.length === 2) {
        e.preventDefault();
        lastTouchDistance = getTouchDistance(e.touches);
    } else if (e.touches.length === 1) {
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
    }
}, { passive: false });

// 터치 이동 이벤트 핸들러
mapContainer.addEventListener('touchmove', function(e) {
    e.preventDefault();

    if (e.touches.length === 2) {
        // 핀치 줌 처리
        const currentDistance = getTouchDistance(e.touches);
        const delta = (currentDistance - lastTouchDistance) / 200; // 감도 조절 (200으로 나누면 더 부드럽게 조정됨)

        const rect = mapContainer.getBoundingClientRect();
        const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left;
        const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;

        const targetScale = Math.min(
            Math.max(mapConfig.minScale, currentScale * (1 + delta)),
            mapConfig.maxScale
        );

        if (Math.abs(currentScale - targetScale) > 0.01) {
            smoothZoom(targetScale, centerX, centerY);  // 확대/축소 적용
            lastTouchDistance = currentDistance;
        }
    } else if (e.touches.length === 1) {
        // 드래그 처리
        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;

        // 최소 이동 거리 체크로 우발적인 이동 방지
        if (!isTouchMoving &&
            (Math.abs(touchX - initialTouchX) > 5 ||
                Math.abs(touchY - initialTouchY) > 5)) {
            isTouchMoving = true;
        }

        if (isTouchMoving) {
            const deltaX = touchX - startX;
            const deltaY = touchY - startY;

            currentTranslateX += deltaX;
            currentTranslateY += deltaY;

            startX = touchX;
            startY = touchY;

            updateMapTransform();
        }
    }
}, { passive: false });

// 터치 종료 이벤트 핸들러
mapContainer.addEventListener('touchend', function() {
    startX = undefined;
    startY = undefined;
    lastTouchDistance = 0;
    
    // 관성 스크롤 방지
    if (isTouchMoving) {
        e.preventDefault();
    }
    
    isTouchMoving = false;
}, { passive: false });

// 터치 취소 이벤트 핸들러
mapContainer.addEventListener('touchcancel', function() {
    startX = undefined;
    startY = undefined;
    lastTouchDistance = 0;
    isTouchMoving = false;
});

// 클릭 이벤트로 정보창과 검색결과 닫기
mapWrapper.addEventListener('click', function() {
    if (activeInfoBox) {
        activeInfoBox.style.display = 'none';
        activeInfoBox = null;
    }
    searchResults.style.display = 'none';
    searchInput.value = '';
});

// 윈도우 리사이즈 이벤트
window.addEventListener('resize', function() {
    updateMapTransform();
    if (activeInfoBox && selectedPin) {
        const pinRect = selectedPin.getBoundingClientRect();
        activeInfoBox.style.left = `${pinRect.left}px`;
        activeInfoBox.style.top = `${pinRect.top - 100}px`;
    }
});

// 앱 초기화
function initializeMap() {
    // 모바일 여부 확인
    const isMobile = window.innerWidth <= 768;
    
    // 모바일/데스크톱에 따른 초기 설정 적용
    currentScale = isMobile ? mapConfig.mobile.initialScale : mapConfig.initialScale;
    
    const wrapperWidth = mapWrapper.offsetWidth;
    const wrapperHeight = mapWrapper.offsetHeight;
    const mapWidth = 1200 * currentScale;
    const mapHeight = 900 * currentScale;
    
    if (isMobile) {
        currentTranslateX = mapConfig.mobile.initialX;
        currentTranslateY = mapConfig.mobile.initialY;
    } else {
        if (mapConfig.initialX === 0 && mapConfig.initialY === 0) {
            currentTranslateX = (wrapperWidth - mapWidth) / 2;
            currentTranslateY = (wrapperHeight - mapHeight) / 2;
        } else {
            currentTranslateX = mapConfig.initialX;
            currentTranslateY = mapConfig.initialY;
        }
    }
    
    updateMapTransform();
}

// 필터 설정
function setupFilters() {
    const filters = ['building-filter', 'floor-filter', 'category-filter'];
    filters.forEach(filterId => {
        document.getElementById(filterId).addEventListener('change', filterPins);
    });
}

// DOM이 로드되면 실행
document.addEventListener('DOMContentLoaded', function() {
    initializeMap();
    initializeFilterOptions();
    setupFilters();
    
    // 모든 핀 생성
    pinsData.forEach(pinData => createPin(pinData.x, pinData.y, pinData));
    
    // 불필요한 필터 적용 버튼 제거
    const applyButton = document.getElementById('apply-filters');
    if (applyButton) {
        applyButton.remove();
    }
});

// 토글 버튼 클릭 시 control-panel 보이기/숨기기
document.getElementById('toggle-button').addEventListener('click', function() {
    const controlPanel = document.querySelector('.control-panel');
    controlPanel.classList.toggle('show');  // 'show' 클래스를 토글하여 표시 여부 결정
});

document.addEventListener('contextmenu', function(event) {
    event.preventDefault();  // 우클릭 방지
});
    </script>
</body>
</html>
