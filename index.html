<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DIMA MAP</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #map-wrapper {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: relative;
            border: 1px solid #ccc;
            background: #f5f5f5;
        }

        #map-container {
            position: absolute;
            transform-origin: 0 0;
            cursor: grab;
            width: 100%;
            height: 100%;
        }

        #map-container:active {
            cursor: grabbing;
        }

        #map-image {
            width: 1200px;
            height: 900px;
            user-select: none;
            object-fit: cover;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }

        .control-panel {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 1200px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            z-index: 9999;
            padding: 20px;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .control-panel h4 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 18px;
        }

        .search-container {
            margin-bottom: 20px;
        }

        .search-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            margin-bottom: 10px;
            box-sizing: border-box;
        }

        .search-results {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 20px;
            border: 1px solid #eee;
            border-radius: 6px;
            display: none;
        }

        .search-result-item {
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
        }

        .search-result-item:hover {
            background: #f5f5f5;
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .filter-group {
            margin-bottom: 15px;
        }

        .filter-group label {
            display: block;
            margin-bottom: 5px;
            color: #666;
            font-size: 14px;
        }

        .filter-select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: white;
            margin-bottom: 10px;
        }

        .filter-button {
            width: 100%;
            padding: 10px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.3s;
        }

        .filter-button:hover {
            background: #1976D2;
        }

        .pin {
            position: absolute;
            width: 30px;
            height: 30px;
            transform: translate(-50%, -100%);
            z-index: 1000;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .pin:hover {
            transform: translate(-50%, -100%) scale(1.1);
        }

        .pin::before {
            content: '';
            position: absolute;
            width: 30px;
            height: 30px;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23E91E63"><path d="M12 0C7.6 0 4 3.6 4 8c0 5.4 8 16 8 16s8-10.6 8-16c0-4.4-3.6-8-8-8zm0 12c-2.2 0-4-1.8-4-4s1.8-4 4-4 4 1.8 4 4-1.8 4-4 4z"/></svg>') no-repeat center center;
            background-size: contain;
        }

        .pin-info-box {
            position: fixed;
            background: white;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: none;
            z-index: 1001;
            max-width: 300px;
            font-size: 14px;
            line-height: 1.6;
        }

        .pin-info-box strong {
            color: #333;
            display: inline-block;
            width: 80px;
        }

        .pin-info-box a {
            color: #2196F3;
            text-decoration: none;
        }

        .pin-info-box a:hover {
            text-decoration: underline;
        }

        .pin-info-box .close-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 18px;
            cursor: pointer;
            color: #666;
            line-height: 1;
        }

        .pin-info-box .close-btn:hover {
            color: #333;
        }

        /* 스크롤바 스타일링 */
        .search-results::-webkit-scrollbar {
            width: 8px;
        }

        .search-results::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .search-results::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }

        .search-results::-webkit-scrollbar-thumb:hover {
            background: #666;
        }

        @media (max-width: 768px) {
    .control-panel {
        padding: 15px;
        font-size: 14px;
    }
    
    .search-input {
        font-size: 16px; /* iOS에서 자동 확대 방지 */
        padding: 8px;
    }
    
    .filter-select {
        font-size: 16px;
        padding: 8px;
    }
    
    .pin {
        width: 24px;
        height: 24px;
    }
    
    .pin-info-box {
        max-width: 280px;
        font-size: 13px;
    }
}

/* 터치 디바이스에서 선택 방지 */
* {
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
}

input, textarea {
    -webkit-user-select: text;
    -khtml-user-select: text;
    -moz-user-select: text;
    -ms-user-select: text;
    user-select: text;
}

    </style>
</head>
<body>
    <div class="control-panel">
        <h4>지도 검색</h4>
        <div class="search-container">
            <input type="text" class="search-input" placeholder="검색어를 입력하세요..." id="search-input">
            <div class="search-results" id="search-results"></div>
        </div>

        <h4>필터링</h4>
        <div class="filter-group">
            <label for="building-filter">건물</label>
            <select id="building-filter" class="filter-select"></select>
        </div>

        <div class="filter-group">
            <label for="floor-filter">층</label>
            <select id="floor-filter" class="filter-select"></select>
        </div>

        <div class="filter-group">
            <label for="category-filter">카테고리</label>
            <select id="category-filter" class="filter-select"></select>
        </div>

        <button id="apply-filters" class="filter-button">필터 적용</button>
    </div>

    <div id="map-wrapper">
        <div id="map-container">
            <img id="map-image" src="map.png" alt="지도" draggable="false">
        </div>
    </div>

    <script>
        네, 모바일 최적화가 포함된 자바스크립트 전체 코드입니다:

```javascript
const mapWrapper = document.getElementById('map-wrapper');
const mapContainer = document.getElementById('map-container');
const searchInput = document.getElementById('search-input');
const searchResults = document.getElementById('search-results');
let pins = [];
let isDragging = false;
let startX, startY;
let currentTranslateX = 0, currentTranslateY = 0, currentScale = 1;
let mode = 'move';
let selectedPin = null;
let activeInfoBox = null;
let touchStartX, touchStartY;
let lastTouchDistance = 0;
let isTouching = false;

// 핀 데이터
const pinsData = [
    {
        "x": "588.89",
        "y": "530.89",
        "building": "체육관",
        "floor": "1",
        "category": "운동",
        "name": "체육관",
        "description": "",
        "address": ""
    },
    {
        "x": "568.89",
        "y": "483.89",
        "building": "대학본부",
        "floor": "1",
        "category": "도서관",
        "name": "도서관",
        "description": "",
        "address": "https://lib.dima.ac.kr/"
    },
    {
        "x": "526.89",
        "y": "368.89",
        "building": "덕성관",
        "floor": "4",
        "category": "실습실",
        "name": "C3 스튜디오",
        "description": "이곳에 들어가면 못나온다~",
        "address": ""
    },
    {
        "x": "573.89",
        "y": "393.89",
        "building": "기예관",
        "floor": "1",
        "category": "실습실",
        "name": "스튜디오",
        "description": "HD부터 다양한 스튜디오가 있음",
        "address": ""
    },
    {
        "x": "254.89",
        "y": "136.89",
        "building": "예인관",
        "floor": "B1",
        "category": "편의시설",
        "name": "GS25",
        "description": "야간 무인운영함",
        "address": ""
    },
    {
        "x": "239.89",
        "y": "201.89",
        "building": "엔터테인먼트관",
        "floor": "2",
        "category": "공연장",
        "name": "대공연장",
        "description": "나중에 디마아트와 연계예정",
        "address": ""
    },
    {
        "x": "263.89",
        "y": "335.89",
        "building": "디마종합촬영소",
        "floor": "1",
        "category": "",
        "name": "디마종합촬영소",
        "description": "자세한정보제공 못함",
        "address": ""
    },
    {
        "x": "654.89",
        "y": "559.89",
        "building": "정류장",
        "floor": "야외",
        "category": "정류장",
        "name": "운동장정류장",
        "description": "",
        "address": ""
    },
    {
        "x": "884.89",
        "y": "631.89",
        "building": "정류장",
        "floor": "야와",
        "category": "정류장",
        "name": "원룸촌 셔틀버스",
        "description": "",
        "address": ""
    }
];

// 설정 객체
const mapConfig = {
    initialScale: 2,
    initialX: -0,
    initialY: -80,
    minScale: 1.6,
    maxScale: 4,
    zoomSpeed: 0.01
};

// 필터 옵션 초기화 함수
function initializeFilterOptions() {
    const buildingFilter = document.getElementById('building-filter');
    const floorFilter = document.getElementById('floor-filter');
    const categoryFilter = document.getElementById('category-filter');

    const buildings = [...new Set(pinsData.map(pin => pin.building))];
    const floors = [...new Set(pinsData.map(pin => pin.floor))];
    const categories = [...new Set(pinsData.map(pin => pin.category))];

    function populateFilter(filter, options) {
        filter.innerHTML = '<option value="">전체</option>';
        options.forEach(option => {
            if (option) filter.innerHTML += `<option value="${option}">${option}</option>`;
        });
    }

    populateFilter(buildingFilter, buildings);
    populateFilter(floorFilter, floors);
    populateFilter(categoryFilter, categories);
}

// 검색 기능
searchInput.addEventListener('input', function() {
    const searchTerm = this.value.toLowerCase();
    if (searchTerm.length < 1) {
        searchResults.style.display = 'none';
        return;
    }

    const filteredPins = pinsData.filter(pin => 
        pin.name.toLowerCase().includes(searchTerm) ||
        pin.building.toLowerCase().includes(searchTerm) ||
        pin.description.toLowerCase().includes(searchTerm)
    );

    searchResults.innerHTML = '';
    if (filteredPins.length > 0) {
        filteredPins.forEach(pin => {
            const resultItem = document.createElement('div');
            resultItem.className = 'search-result-item';
            resultItem.innerHTML = `
                <div><strong>${pin.name}</strong></div>
                <div>${pin.building} ${pin.floor}</div>
            `;
            resultItem.addEventListener('click', () => {
                const pinObj = pins.find(p => 
                    p.coordinates.x === pin.x && 
                    p.coordinates.y === pin.y
                );
                if (pinObj) {
                    moveToPin(pinObj.pin);
                    showPinInfoBox(pinObj.pin, pin);
                }
                searchResults.style.display = 'none';
                searchInput.value = '';
            });
            searchResults.appendChild(resultItem);
        });
        searchResults.style.display = 'block';
    } else {
        searchResults.style.display = 'none';
    }
});

// 지도 초기화 및 업데이트 함수들
function initializeMap() {
    currentScale = mapConfig.initialScale;
    const wrapperWidth = mapWrapper.offsetWidth;
    const wrapperHeight = mapWrapper.offsetHeight;
    const mapWidth = 1200 * currentScale;
    const mapHeight = 900 * currentScale;
    
    if (mapConfig.initialX === 0 && mapConfig.initialY === 0) {
        currentTranslateX = (wrapperWidth - mapWidth) / 2;
        currentTranslateY = (wrapperHeight - mapHeight) / 2;
    } else {
        currentTranslateX = mapConfig.initialX;
        currentTranslateY = mapConfig.initialY;
    }
    
    updateMapTransform();
}

function updateMapTransform() {
    const wrapperWidth = mapWrapper.offsetWidth;
    const wrapperHeight = mapWrapper.offsetHeight;
    const mapWidth = 1200 * currentScale;
    const mapHeight = 900 * currentScale;
    
    if (mapWidth > wrapperWidth) {
        currentTranslateX = Math.min(0, Math.max(currentTranslateX, wrapperWidth - mapWidth));
    } else {
        currentTranslateX = (wrapperWidth - mapWidth) / 2;
    }
    
    if (mapHeight > wrapperHeight) {
        currentTranslateY = Math.min(0, Math.max(currentTranslateY, wrapperHeight - mapHeight));
    } else {
        currentTranslateY = (wrapperHeight - mapHeight) / 2;
    }
    
    mapContainer.style.transform = `translate(${currentTranslateX}px, ${currentTranslateY}px) scale(${currentScale})`;
}

// 터치 이벤트 핸들러
mapContainer.addEventListener('touchstart', function(e) {
    isTouching = true;
    if (e.touches.length === 2) {
        lastTouchDistance = getTouchDistance(e.touches);
    } else if (e.touches.length === 1) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
    }
}, { passive: false });

mapContainer.addEventListener('touchmove', function(e) {
    e.preventDefault();
    
    if (!isTouching) return;
    
    if (e.touches.length === 2) {
        const currentDistance = getTouchDistance(e.touches);
        const delta = (currentDistance - lastTouchDistance) / 200;
        
        const rect = mapContainer.getBoundingClientRect();
        const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left;
        const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;
        
        const targetScale = Math.min(Math.max(mapConfig.minScale, currentScale * (1 + delta)), mapConfig.maxScale);
        currentScale = targetScale;
        
        updateMapTransform();
        lastTouchDistance = currentDistance;
        
    } else if (e.touches.length === 1) {
        const deltaX = e.touches[0].clientX - touchStartX;
        const deltaY = e.touches[0].clientY - touchStartY;
        
        currentTranslateX += deltaX;
        currentTranslateY += deltaY;
        
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        
        updateMapTransform();
    }
}, { passive: false });

mapContainer.addEventListener('touchend', function() {
    isTouching = false;
    lastTouchDistance = 0;
});

function getTouchDistance(touches) {
    return Math.hypot(
        touches[0].clientX - touches[1].clientX,
        touches[0].clientY - touches[1].clientY
    );
}

// 마우스 이벤트 핸들러들
mapContainer.addEventListener('mousedown', (e) => {
    if (mode !== 'move') return;
    isDragging = true;
    startX = e.clientX;
    startY = e.clientY;
    mapContainer.style.cursor = 'grabbing';
});

document.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    e.preventDefault();
    const deltaX = e.clientX - startX;
    const deltaY = e.clientY - startY;
    
    currentTranslateX += deltaX;
    currentTranslateY += deltaY;
    
    startX = e.clientX;
    startY = e.clientY;
    
    updateMapTransform();

    if (activeInfoBox && selectedPin) {
        const pinRect = selectedPin.getBoundingClientRect();
        activeInfoBox.style.left = `${pinRect.left}px`;
        activeInfoBox.style.top = `${pinRect.top - 120}px`;
    }
});

document.addEventListener('mouseup', () => {
    isDragging = false;
    mapContainer.style.cursor = 'grab';
});

// 기타 이벤트 리스너들
mapWrapper.addEventListener('wheel', function(e) {
    e.preventDefault();
    const rect = mapContainer.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    const delta = e.deltaY > 0 ? -mapConfig.zoomSpeed : mapConfig.zoomSpeed;
    let targetScale = Math.min(Math.max(mapConfig.minScale, currentScale * (1 + delta)), mapConfig.maxScale);

    const wrapperWidth = mapWrapper.offsetWidth;
    const wrapperHeight = mapWrapper.offsetHeight;
    const imageAspectRatio = 1200 / 900;
    const wrapperAspectRatio = wrapperWidth / wrapperHeight;
    
    let minScale = wrapperAspectRatio > imageAspectRatio ? 
        wrapperHeight / 900 : wrapperWidth / 1200;

    if (targetScale >= minScale) {
        smoothZoom(targetScale, mouseX, mouseY);
    }
});

let zoomAnimation;
function smoothZoom(targetScale, mouseX, mouseY) {
    if (zoomAnimation) {
        cancelAnimationFrame(zoomAnimation);
    }

    const startScale = currentScale;
    const scaleDiff = targetScale - startScale;
    const startTime = performance.now();
    const duration = 300;

    function animate(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        const easeProgress = progress < 0.5 
            ? 2 * progress * progress 
            : 1 - Math.pow(-2 * progress + 2, 2) / 2;
        
        const newScale = startScale + (scaleDiff * easeProgress);
        
        const beforeX = mouseX / currentScale;
        const beforeY = mouseY / currentScale;
        
        currentScale = newScale;
        
        const afterX = mouseX / currentScale;
        const afterY = mouseY / currentScale;
        
        currentTranslateX += (afterX - beforeX) * currentScale;
        currentTranslateY += (afterY - beforeY) * currentScale;
        
        updateMapTransform();
        
        if (progress < 1) {
            zoomAnimation = requestAnimationFrame(animate);
        }
    }
    
    zoomAnimation = requestAnimationFrame(animate);
}

function moveToPin(pin) {
    const pinRect = pin.getBoundingClientRect();
    const wrapperRect = mapWrapper.getBoundingClientRect();
    
    const targetX = -(pin.offsetLeft * currentScale - (wrapperRect.width / 2));
    const targetY = -(pin.offsetTop * currentScale - (wrapperRect.height / 2));
    
    mapContainer.style.transition = 'transform 0.5s ease-out';
    currentTranslateX = targetX;
    currentTranslateY = targetY;
    updateMapTransform();
    
    setTimeout(() => {
        mapContainer.style.transition = '';
    }, 500);
}

function createPin(x, y, details = {}) {
    const pin = document.createElement('div');
    pin.className = 'pin';
    pin.style.left = `${x}px`;
    pin.style.top = `${y}px`;

    pin.addEventListener('click', function(e) {
        e.stopPropagation();
        showPinInfoBox(pin, details);
    });

    mapContainer.appendChild(pin);
    pins.push({
        pin,
        coordinates: { x, y },
        ...details
    });
}

function showPinInfoBox(pin, pinData) {
    if (activeInfoBox) {
        activeInfoBox.style.display = 'none';
    }

    const pinRect = pin.getBoundingClientRect();
    const infoBox = document.createElement('div');
    infoBox.className = 'pin-info-box';
    
    infoBox.style.left = `${pinRect.left}px`;
    infoBox.style.top = `${pinRect.top - 120}px`;

    const closeBtn = document.createElement('span');
    closeBtn.className = 'close-btn';
    closeBtn.innerHTML = '×';
    closeBtn.onclick = function(e) {
        e.stopPropagation();
        infoBox.style.display = 'none';
        activeInfoBox = null;
    };
    infoBox.appendChild(closeBtn);

    infoBox.innerHTML += `
        <strong>이름:</strong> ${pinData.name || '미정'}<br>
        <strong>건물:</strong> ${pinData.building || '미정'}<br>
        <strong>층:</strong> ${pinData.floor || '미정'}<br>
        <strong>카테고리:</strong> ${pinData.category || '미정'}<br>
        <strong>설명:</strong> ${pinData.description || '미정'}<br>
        <strong>주소:</strong> 
        ${pinData.address ? `<a href="${pinData.address}" target="_blank">${pinData.address}</a>` : '미정'}
    `;
    
    document.body.appendChild(infoBox);
    infoBox.style.display = 'block';
    activeInfoBox = infoBox;
    selectedPin = pin;

    const infoBoxRect = infoBox.getBoundingClientRect();
    if (infoBoxRect.top < 0) {
        infoBox.style.top = '10px';
    }
    if (infoBoxRect.left < 0) {
        infoBox.style.left = '10px';
    }
    if (infoBoxRect.right > window.innerWidth) {
        infoBox.style.left = `${window.innerWidth - infoBoxRect.width - 10}px`;
    }
}

function filterPins() {
    const buildingFilter = document.getElementById('building-filter').value;
    const floorFilter = document.getElementById('floor-filter').value;
    const categoryFilter = document.getElementById('category-filter').value;

    pins.forEach(pinObj => {
        const matchesBuilding = buildingFilter ? pinObj.building === buildingFilter : true;
        const matchesFloor = floorFilter ? pinObj.floor === floorFilter : true;
        const matchesCategory = categoryFilter ? pinObj.category === categoryFilter : true;

        pinObj.pin.style.display = 
            (matchesBuilding && matchesFloor && matchesCategory) ? 'block' : 'none';
    });
}

function setupFilters() {
    const filters = ['building-filter', 'floor-filter', 'category-filter'];
    filters.forEach(filterId => {
        document.getElementById(filterId).addEventListener('change', filterPins);
    });
}

mapWrapper.addEventListener('click', function() {
    if (activeInfoBox) {
        activeInfoBox.style.display = 'none';
        activeInfoBox = null;
    }
    searchResults.style.display = 'none';
    searchInput.value = '';
});

window.addEventListener('resize', function() {
    updateMapTransform();
    if (activeInfoBox && selectedPin) {
        const pinRect = selectedPin.getBoundingClientRect();
        activeInfoBox.style.left = `${pinRect.left}px`;
        activeInfoBox.style.top = `${pinRect.top - 120}px`;
    }
});

document.addEventListener('DOMContentLoaded', function() {
    initializeMap();
    initializeFilterOptions();
    setupFilters();
    pinsData.forEach(pinData => createPin(pinData.x, pinData.y, pinData));
    
    const applyButton = document.getElementById('apply-filters');
    if (applyButton) {
        applyButton.remove();
    }
});

    </script>
</body>
</html>
